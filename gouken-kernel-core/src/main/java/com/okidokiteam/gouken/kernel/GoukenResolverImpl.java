package com.okidokiteam.gouken.kernel;import java.io.IOException;import java.io.InputStream;import javax.inject.Inject;import javax.inject.Named;import com.okidokiteam.gouken.ArtifactReference;import com.okidokiteam.gouken.GoukenResolver;import org.ops4j.pax.repository.Index;import org.ops4j.pax.repository.Mapping;import org.ops4j.pax.repository.Provider;import org.ops4j.pax.repository.RepositoryException;import org.ops4j.pax.repository.base.helpers.CachedProvider;import org.ops4j.pax.repository.maven.GAV;import org.ops4j.pax.repository.typed.TypedRepository;import org.ops4j.store.Handle;import org.ops4j.store.Store;/** * Specific implementation. * Here's also where you wire up the whole Pax Repository runtime stuff. * This one uses Guice and the (shipped with Pax Repository) Guice Modules for tight configuration. * * TODO: Replaced by {@code MappingResolver} from Pax Repo ? * * This is an example of a hybrid resolver for different styles of {@link ArtifactReference}. * Remember, {@link ArtifactReference} is fully project specific, thus it is fully in your control. * And so is {@link GoukenResolverImpl}. You inject the correct repositories and indexes, and * delegate the queries ({@link GoukenResolverImpl#find(com.okidokiteam.gouken.ArtifactReference)} to * underlying resource provided by Pax Repository. */public class GoukenResolverImpl implements GoukenResolver {    /**     * Usually you need an index. This will let you query against (untyped) key in a repository.     * Resources that you do not contribute yourself in this application are usually derived by {@link Index}.     */    final private Index<GAV, GAV, InputStream> m_index;    /**     * This lets you query against a typed repo that has been "filled" in other areas of the system.     * This resolver is responsible to convert the return type of this repo to a provider implementation.     */    final private TypedRepository<Handle> m_typedRepo;    final private Mapping<String, GAV> m_parser;    final private Store<InputStream> m_store;    @Inject    @Named( "gouken" )    GoukenResolverImpl(        Store<InputStream> store,        Index<GAV, GAV, InputStream> index,        Mapping<String, GAV> parser,        TypedRepository<Handle> typedRepo )    {        m_store = store;        m_index = index;        m_parser = parser;        m_typedRepo = typedRepo;    }    /**     * This checks the given {@link ArtifactReference}, possibly parses data and access one of the underlying repositories or indexes for data.     *     * @param ref the actual data     *     * @throws RepositoryException In case anything can not be loaded (for whatever reason).     */    public Provider<InputStream> find( ArtifactReference ref )        throws RepositoryException    {        if( ref.untyped() != null ) {            // 1. untyped, parse and route to m_index.            // convert ref to gav type.            // parse the instruction using a default maven string parser:            GAV gav = m_parser.parse( ref.untyped() );            return m_index.get( gav );        }        else {            // 2. typed, route to m_typedRepo            try {                return new CachedProvider<InputStream>( m_store, m_typedRepo.get( ref.typed() ).get() );            } catch( IOException e ) {                throw new RepositoryException( "Cannot load value for typed reference " + ref.typed() );            }        }    }}
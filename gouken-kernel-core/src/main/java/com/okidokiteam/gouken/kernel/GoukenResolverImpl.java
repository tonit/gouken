package com.okidokiteam.gouken.kernel;import java.io.IOException;import java.io.InputStream;import javax.inject.Inject;import com.okidokiteam.gouken.ArtifactReference;import com.okidokiteam.gouken.GoukenResolver;import org.ops4j.pax.repository.Index;import org.ops4j.pax.repository.Mapping;import org.ops4j.pax.repository.Provider;import org.ops4j.pax.repository.RepositoryException;import org.ops4j.pax.repository.base.helpers.CachedProvider;import org.ops4j.pax.repository.maven.GAV;import org.ops4j.pax.repository.typed.TypedRepository;import org.ops4j.store.Handle;import org.ops4j.store.Store;/** * Specific implementation. * Here's also where you wire up the whole Pax Repository runtime stuff. * This one uses Guice and the (shipped with Pax Repository) Guice Modules for tight configuration. * * TODO: Replaced by {@code MappingResolver} from Pax Repo ? * * This is an example of a hybrid resolver for different styles of {@link ArtifactReference}. * Remember, {@link ArtifactReference} is fully project specific, thus it is fully in your control. * And so is {@link GoukenResolverImpl}. You inject the correct repositories and indexes, and * delegate the queries ({@link GoukenResolverImpl#find(com.okidokiteam.gouken.ArtifactReference)} to * underlying resource provided by Pax Repository. */public class GoukenResolverImpl implements GoukenResolver {    final private Index<GAV, GAV, InputStream> m_index;    final private Mapping<String, GAV> m_parser;    final private Store<InputStream> m_store;    final private TypedRepository<Handle> m_typedRepo;    @Inject    GoukenResolverImpl(        Store<InputStream> store,        Index<GAV, GAV, InputStream> index,        Mapping<String, GAV> parser,        TypedRepository<Handle> typedRepo )    {        m_store = store;        m_index = index;        m_parser = parser;        m_typedRepo = typedRepo;    }    public Provider<InputStream> find( ArtifactReference ref )        throws RepositoryException    {        if( ref.untyped() != null ) {            // 1. untyped, parse and route to m_index.            // convert ref to gav type.            // parse the instruction using a default maven string parser:            GAV gav = m_parser.parse( ref.untyped() );            return m_index.get( gav );        }        else {            // 2. typed, route to m_typedRepo            try {                return new CachedProvider<InputStream>( m_store, m_typedRepo.get( ref.typed() ).get() );            } catch( IOException e ) {                throw new RepositoryException( "Cannot load value for typed reference " + ref.typed() );            }        }    }}